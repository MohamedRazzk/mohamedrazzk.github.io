[
  
  {
    "title": "InsomniHackTeaser Crypto 18 - Rule86",
    "url": "/posts/InsomniHack-Teaser-18/",
    "categories": "Cryptography Engineering",
    "tags": "Cryptography, Pyhton, InsomniHackTeaser-Cryptography Engineering",
    "date": "2020-07-13 08:10:00 +0200",
    





    
    "snippet": "Inroduction  InsomniHack Teaser CTF 2018 - Rule86DescriptionKevin is working on a new synchronous stream cipher, but he has been re-using his key.In this challenge, you are provided with 4 files:hi...",
    "content": "Inroduction  InsomniHack Teaser CTF 2018 - Rule86DescriptionKevin is working on a new synchronous stream cipher, but he has been re-using his key.In this challenge, you are provided with 4 files:hint.gif.enc          - An encrypted GIFsuper_cipher.py.enc   - An encrypted python scriptrule86.txt            - A cleartext file rule86.txt.enc        - The encrypted version of said fileWriteupStep 1we started by getting the keystream from the rule86.txt file and its encrypted counterpartp1 = open('rule86.txt', 'rb').read()c1 = open('rule86.txt.enc', 'rb').read()keystream = []for a, b in zip(p1, c1):    keystream.append(a ^ b)And then, decrypting the other encrypted filesc2 = open('super_cipher.py.enc', 'rb').read()p2 = []for a, b in zip(keystream, c2):    p2.append(a ^ b)print(bytes(p2))Since the rule86.txt.enc file is smaller then super_cipher.py.enc and hint.gif.enc we don’t have enough keystream to decrypt the latters.Step 2We noticed that the decrypted script was generating a 32-byte integer with a PRNG from the key (aka the flag) and using that as keystream.RULE = [86 &gt;&gt; i &amp; 1 for i in range(8)]N_BYTES = 32N = 8 * N_BYTESdef next(x):  x = (x &amp; 1) &lt;&lt; N+1 | x &lt;&lt; 1 | x &gt;&gt; N-1  y = 0  for i in range(N):    y |= RULE[(x &gt;&gt; i) &amp; 7] &lt;&lt; i  return y# Bootstrap the PNRGkeystream = int.from_bytes(args.key.encode(),'little')for i in range(N//2):  keystream = next(keystream)The simple way to solve this and decrypt the gif and the script was to retrive the starting 32-byte integer from the known keystream and then using the PRNG function to reproduce the keystream by generating all the integer we wanted.So I’ve made a recreate script part of the gif following this pattern.#!/usr/bin/python3l1=[b'\\x00', b'\\x2b', b'\\x55', b'\\x80', b'\\xaa', b'\\xd5', b'\\xff']l2=[b'\\x00', b'\\x33', b'\\x66', b'\\x99', b'\\xcc', b'\\xff']header = b'\\x47\\x49\\x46\\x38\\x39\\x61\\x67\\x02\\xE6\\x00\\xF7\\x00\\x00'ary = b'' + headerfor i in l2:    for j in l1:        for k in l2:            ary += i + j + kgne = open('hint_full.gif', 'wb')gne.write(ary)gne.close()# l1 l2 l1 l1 l2 l1 l1 l2 l1 l1 l2 l1 l1 l2 l1 l1 l2 l1# 00 00 00 00 00 33 00 00 66 00 00 99 00 00 CC 00 00 FF# 00 2B 00 00 2B 33 00 2B 66 00 2B 99 00 2B CC 00 2B FF# 00 55 00 00 55 33 00 55 66 00 55 99 00 55 CC 00 55 FFAll went smooth and without problem so I kept thinking it was the good approach, beside that the gif was corrupted, but the keystream was right and we decrypted all the scriptScript for recovering the super_cipher.py file#!/usr/bin/python3p1 = open('rule86.txt', 'rb').read()c1 = open('rule86.txt.enc', 'rb').read()c2 = open('super_cipher.py.enc', 'rb').read()c3 = open('hint.gif.enc', 'rb').read()# get the first part of the keystreamkeystream = []for a, b in zip(p1, c1):  keystream.append(a ^ b)# decrypt the gif filep3 = []for a, b in zip(keystream, c3):  p3.append(a ^ b)    with open('hint2.gif', 'wb') as f:  f.write(bytes(p3))# run giffer.py to generate hint_full.gif# get another keystream partkeystream = []gif = open('hint_full.gif', 'rb').read()for a, b in zip(c3, gif):  keystream.append(a ^ b)# decrypt the full python scriptp2 = []for a, b in zip(keystream, c2):  p2.append(a ^ b)print(bytes(p2).decode())    with open('super_cipher1.py', 'w') as f:  f.write(bytes(p2).decode())Step 3Now we know that the flag is the seed of the PRNG used as encryption keystream.We only need to reverse it and get the previous number for each step. Easy.Let’s start from this line.x = (x &amp; 1) &lt;&lt; N+1 | x &lt;&lt; 1 | x &gt;&gt; N-1(x &amp; 1) get the lsb from x (our starting number)(x &amp; 1) &lt;&lt; N+1 will shift it 257 positions left (N = 256)if x lsb is 0, (x &amp; 1) &lt;&lt; N+1 will be 0if x lsb is 1. (x &amp; 1) &lt;&lt; N+1 will be 1 &lt;&lt; 257x &lt;&lt; 1 shift x by 1 position to the leftx &gt;&gt; N-1 will take the 2 msb, shift them by 255 positions right and OR them as lsbTurns out this is very easy to reverse and also the output number has its 2 msb equals to its 2 lsb.The reverse operation is the following: x = (x &gt;&gt; 1) &amp; ((1 &lt;&lt; N)-1)x &gt;&gt; 1 shift x by 1 position right, eliminating the 2 lsb added above.The AND operation filters the first operand’s bits where the second operand has bits set to 1. (1 &lt;&lt; N) is 0b1000000 with N zeros. Minus one will result in 0b111111 with N ones.We are effectively filtering only the N bits we wanted, eliminating the 2 msb added above.Then the PRNG takes 3 bits at a time from the right and substitute them by the RULE array.for i in range(N):    y |= RULE[(x &gt;&gt; i) &amp; 7] &lt;&lt; iFor example if we have 0b1100, the for works like this:y[0] = RULE[0b100] # 0bXXX100y[1] = RULE[0b110] # 0bXX110X y[2] = RULE[0b11]  # 0bX011XXy[3] = RULE[0b1]   # 0b001XXXy = y[::-1]        # reverse y Output y will be 0b1011Reversing this is pretty easy too, just scan y and get the possible preimage values of RULE mapping function that result in either 1 or 0.If the current y bit is 1, check what value in RULE output 1 and check if that value is consistent with the previous ones (since chosen bits form x are overlapping)To recovery  the integer keystreamimport sysRULE = [86 &gt;&gt; i &amp; 1 for i in range(8)]N_BYTES = 32N = 8 * N_BYTESdef next(x):  x = (x &amp; 1) &lt;&lt; N+1 | x &lt;&lt; 1 | x &gt;&gt; N-1  y = 0  for i in range(N):    y |= RULE[(x &gt;&gt; i) &amp; 7] &lt;&lt; i  return yp = open('rule86.txt','rb')c = open('rule86.txt.enc','rb')plaintext = p.read(N_BYTES)ciphertext = c.read(N_BYTES)# print the full keystreamwhile plaintext:  x = int.from_bytes(plaintext,'little') ^ int.from_bytes(ciphertext,'little')  print(x)  plaintext = p.read(N_BYTES)  ciphertext = c.read(N_BYTES)For reverseing the PRNG and get the seed/flagRULE = [86 &gt;&gt; i &amp; 1 for i in range(8)]N_BYTES = 32N = 8 * N_BYTESdef next(x,n=N):  x = (x &amp; 1) &lt;&lt; N+1 | x &lt;&lt; 1 | x &gt;&gt; N-1  y = 0  for i in range(N):    y |= RULE[(x &gt;&gt; i) &amp; 7] &lt;&lt; i  return ydef reverse(y):  valid = []                            # declare a valid array since the preimage of a value according                                        # to the rule can be the result of 4 different input    ycell = y &amp; 0b1                       # get the last bit  for j in range(len(RULE)):            # for every rule     if RULE[j] == ycell:                # check if the result match our expected value      valid.append(j)                   # add the value as valid    for i in range(1, N):                 # for every bit in y (should be 256/258 bit)    newvalid = []    for v in valid:                     # for every previous valid value      ycell = (y &gt;&gt; i) &amp; 0b1            # get the y target cell (1 bit)      xcell = (v &gt;&gt; i) &amp; 0b011          # get the x target cell (2 bit out of 3) from the previous valid      for j in range(len(RULE)):                if RULE[j] == ycell:          if (j &amp; 0b011) == xcell:      # check if the result match our target one            v |= (j &lt;&lt; i)               # \"add\" our match to the already valid one            newvalid.append(v)          # update the valid list    valid = newvalid  x = None  for v in valid:                       # for every valid 256 bit value    if (v &gt;&gt; 256) == (v &amp; 0b11):        # check if the 2 msb are equals to the 2 lsb      x = v                             # we found our previous x   if x is None:    print(\"Error no valid integer!\")    exit(1)            x = (x &gt;&gt; 1) &amp; ((1 &lt;&lt; N)-1)           # fix our x accordingly  return x#values from the keystreaml = [37450399269036614778703305999225837723915454186067915626747458322635448226786,100622653914913501834016856771730649612864879431221716975620828032766397709367,30565965598786057661696410930164890805958057693583615925316094177133280560720,103573567656710023306192266386049368645675636074643938780342918703636500548568,28509515191943075455625810763252620824333983857860790449437105502768741406797,87537284303558144156631836069957764733725337398790274426598731583572530580725,44716782229954850790645591045965014941901610454109696374926338641251779999508,82447195088123999846117257332504341489187184956851468679950679621555020370358,66901809945344917781374326984783824023739095925450107364519045210557505092242,114067135427233025222698564170101622975443616062287263643297019211756836637438,2884516673931260333907001189797696957250433333677043264446344069828816140802,5289872070696193140037770894656341630909797897334877860267293814493245082375,69023781971677661808035522723190242410127104903614192265146189107040377117065,107613775284599791185420266567845597101440592435618453390961765397563059875550,16357066489843479901612193664610011889060446509506296924636891723597443981890,57186523063755103597333412726627151956381596060761612487300750841069890516967]# try to reverse the keystreamfor i in range(len(l)-1,0,-1):  next(l[i-1])  a = reverse(l[i])  if a != l[i-1]:    print('Error in keystream')    exit()  print('OK ---',i)  print(\"YOU ROCK! Keystream reversed.\\nReversing 128 bootstrap rounds...\")# after this you should go 128 block reverse and get the PRNG seed aka FLAGcurr = l[1]for i in range(0,129):  curr = reverse(curr)print(\"128 rounds done.\\nPrinting flag...\\n\")print(curr.to_bytes(N_BYTES,'little').decode())` Flag is Captured ` » INS{Rule86_is_W0lfr4m_Cha0s}"
  },
  
  {
    "title": "RITSEC Crypto 18 - CictroHash",
    "url": "/posts/RITSEC-18-CictroHash/",
    "categories": "Cryptography Engineering, RITSEC-CTF",
    "tags": "Cryptography, Pyhton, RITSEC-Cryptography Engineering",
    "date": "2019-03-18 08:10:00 +0200",
    





    
    "snippet": "Inroduction  RITSEC CTF 2018 - CictroHashDescriptionFor this challenge you must implement the described Hash Function and then find a collision of two strings.Once a collision is found send both st...",
    "content": "Inroduction  RITSEC CTF 2018 - CictroHashDescriptionFor this challenge you must implement the described Hash Function and then find a collision of two strings.Once a collision is found send both strings to fun.ritsec.club:8003 as a HTTP POST request like below:curl -X POST http://fun.ritsec.club:8003/checkCollision –header “Content-Type: application/json” –data ‘{“str1”: “”, “str2”: “”}’If the strings are a valid collision then the flag will be returned.NOTE: requests to this server are being rate-limited for obvious reasons.Author: CictroneWriteupThis crypto challenge was really original and very interesting.We started writing the implementation for the CictroHash sponge function, after some ranting for the incomplete specification and the incorrect text vector.Then we based our output on the hashes returned by the server.Once our implementation was exact, we noticed that the permutation function only acted on some bits and didn’t provide enough diffusion so the avalanche effect was minimum in some cases.For example you can see how “HELLOWORLD” and “HELLOWORLD0” only differs by 2 bit in the 3rd byte&gt;&gt;&gt; CictroHash.hash(\"HELLOWORLD\")\"91f1c05e\"&gt;&gt;&gt; CictroHash.hash(\"HELLOWORLD0\")\"91f1005e\"&gt;&gt;&gt;&gt;&gt;&gt; '{:08b}'.format(0x00)'00000000'&gt;&gt;&gt; '{:08b}'.format(0xc0)'11000000'CictroHash Scriptclass CictroHash:\tdef __init__(self):\t\tself.initialize_state()\tdef initialize_state(self):\t\tself.S = [[31, 56, 156, 167], [38, 240, 174, 248]]\tdef r(self):\t\treturn self.S[0]\tdef c(self):\t\treturn self.S[1]\tdef hash(self, text):\t\ttext = self.pad(self.prepare(text))\t\tblocks = [text[i:i + 4] for i in range(0, len(text), 4)]\t\tfor b in blocks:\t\t\tself.absorb(b)\t\treturn self.squeeze()\tdef pad(self, t):\t\tt.extend([0] * (4 - len(t) % 4))\t\treturn t\tdef prepare(self, text):\t\treturn [ord(i) for i in text]\tdef absorb(self, P):\t\tself.S[0] = self.xor(P, self.S[0])\t\tfor i in range(50):\t\t\tself.round()\tdef squeeze(self):\t\treturn ''.join(['{:02x}'.format(b) for b in self.S[0]])\tdef xor(self, a, b):\t\treturn [c ^ p for c, p in zip(a, b)]\tdef round(self):\t\tself.alfa()\t\tself.beta()\t\tself.gamma()\t\tself.delta()\t\treturn self.S\tdef alfa(self):\t\tself.S[0], self.S[1] = self.S[1], self.S[0]\tdef beta(self):\t\tfor i in range(0, len(self.S[1])):\t\t\tself.S[0][i] ^= self.S[1][len(self.S[1]) - 1 - i]\tdef gamma(self):\t\tS1 = [\t\t\t[self.S[1][3], self.S[1][0], self.S[1][2], self.S[0][0]],\t\t\t[self.S[1][1], self.S[0][3], self.S[0][1], self.S[0][2]]\t\t]\t\tself.S = S1\tdef delta(self):\t\tself.S[0][0] = self.rol(self.S[0][0])\t\tself.S[1][0] = self.rol(self.S[1][0])\t\tself.S[0][2] = self.rol(self.S[0][2])\t\tself.S[1][2] = self.rol(self.S[1][2])\t\tself.S[0][1] = self.ror(self.S[0][1])\t\tself.S[1][1] = self.ror(self.S[1][1])\t\tself.S[0][3] = self.ror(self.S[0][3])\t\tself.S[1][3] = self.ror(self.S[1][3])\tdef rol(self, c):\t\treturn ((c &lt;&lt; 1) | (c &gt;&gt; 7)) &amp; 0xff\tdef ror(self, c):\t\treturn ((c &gt;&gt; 1) | (c &lt;&lt; 7)) &amp; 0xff# Testingfor w in [\t(\"HELLOWORLD\", \"91f1c05e\"),\t(\"HELLOWORLD0\", \"91f1005e\"),]:\th = CictroHash()\tassert(h.hash(w[0]) == w[1])# \"Differential\" analysisXOR = [0b00000001, 0b00000010, 0b00001000, 0b00010000, 0b00100000, 0b01000000, 0b10000000]seed = [\"H\", \"E\", \"L\", \"L\", \"O\", \"W\", \"O\", \"R\", \"L\", \"D\"]found = {}for x in XOR:\tfor i in range(len(seed)):\t\ttmp = seed.copy()\t\th = CictroHash()\t\ttmp[i] = chr(ord(seed[i]) ^ x)\t\tchash = h.hash(\"\".join(tmp))\t\tif found.get(chash):\t\t\tprint(chash, found[chash], \"\".join(tmp))\t\t\texit()\t\tfound[chash] = \"\".join(tmp)  Bitflip one bit at a time the pre-image searching for a collision91f1405e - HENLOWORLD - HELLOWGRLD"
  },
  
  {
    "title": "TAMU Crypto 18 - LarryCrypt",
    "url": "/posts/TAMU-18-LarryCrypt/",
    "categories": "Cryptography Engineering, TAMU-CTF",
    "tags": "Cryptography, Pyhton, TAMU-Cryptography Engineering",
    "date": "2019-01-12 08:10:00 +0200",
    





    
    "snippet": "Inroduction  TAMU CTF 2018 - LarryCryptDescriptionA binary executable called larrycrypt was provided../larrycrypt -R 4 -K “V3c70R” flagWriteupWe tried some input for the larrycrypt binary and we no...",
    "content": "Inroduction  TAMU CTF 2018 - LarryCryptDescriptionA binary executable called larrycrypt was provided../larrycrypt -R 4 -K “V3c70R” flagWriteupWe tried some input for the larrycrypt binary and we noticed that it was always using Mu as key, no matter what was the -K parameter.It was likely some bug, but then the SimpleDES challenge  we just solved came to our minds.The binary was using the same key as the other challenge’s example.So we thought it was using the same algorithm, but it wasn’t the case.Larrycrypt was using 6bit blocks for the ciphertext.The first block of ciphertext was the same as SimpleDES’s first 6bit of cyphertext when using the same key and the same number of rounds. With some more reverse engineering we figured out that larrycrypt was taking the first 12 bits of plaintext, splitting them into L0 and R0, performing the round function and printing only the resulting L1.So they were using the same round function.But then the sequence changes, we take the R output from the round function and use it as L for the next round along with the next block of ciphertext.This image shows an example on 3 blocks of data, the output cypertext is made of cypher0, cypher1. L2 won’t be printedTo decrypt this we need to bruteforce all the possible 6bit last blocks (L2 in the image), decrypt all the blocks and check if the plaintext is good use the previous des pyhton script and the bruteforce the plain textScriptsimport simple_desclass SimplerDES(simple_des.SimpleDES):    def encrypt(self, data):        if len(data[0]) == 8:            data = simple_des.to_twelve(data)        result = []        for block in data:            a,b = self.split_block(block)            result.extend([a,b])        data = result        result = []        self.schedule_key(len(data))        Lr = data[0]        for i in range(0,len(data)-1):            Rr = data[i+1]            for r in range(self.rounds):                sk = self.subkeys[i][r]                Lr, Rr = self.round(sk, Lr, Rr)            result.append(Lr)            Lr = Rr        return result        def decrypt(self, data, last):        self.invert_key(len(data))        result = []        Lr = last        for i in range(len(data),0,-1):            i -=1 # hotfix            Rr = data[i]            for r in range(self.rounds):                sk = self.subkeys[i][r]                Lr, Rr = self.round(sk, Lr, Rr)            result.append(Lr)            Lr = Rr        result.reverse()        return resultimport itertools#fi = open('flags.txt','w')ciphertext = ['000101','000000','100111','011001','101110','011101','001110','101111','010001','101111','110000','001001','110010','111011','110111','010001','000100','101011','100010','100010','000001','010100','001111','010010','111110','001110','000111']key = simple_des.ascii_to_bin(\"Mu\")f = SimplerDES(key, rounds=4)for i in itertools.product('01', repeat=6):    decrypted = f.decrypt(ciphertext, ''.join(i))    l = ''.join(decrypted)    #fi.write(l+'\\n')    if simple_des.bin_to_ascii(l[-8:]) == '}':        l = '010001'+l # fix the starting G  :D        print(simple_des.bin_to_ascii(l))    #fi.close()    "
  },
  
  {
    "title": "TAMU Crypto 18 - SimpleDES",
    "url": "/posts/TAMU-18-SimpleDES/",
    "categories": "Cryptography Engineering, TAMU-CTF",
    "tags": "Cryptography, Pyhton, TAMU-Cryptography Engineering",
    "date": "2018-12-06 08:10:00 +0200",
    





    
    "snippet": "Inroduction  TAMU CTF 2018 - SimpleDESDescriptionLarry is working on an encryption algorithm based on DES. He hasn’t worked out all the kinks yet, but he thinks it works. Your job is to confirm tha...",
    "content": "Inroduction  TAMU CTF 2018 - SimpleDESDescriptionLarry is working on an encryption algorithm based on DES. He hasn’t worked out all the kinks yet, but he thinks it works. Your job is to confirm that you can decrypt a message, given the algorithm and parameters used.The organizer gave us a specification about this simpleDES cipher: His system works as follows:    - Choose a plaintext that is divisible into 12bit 'blocks'    - Choose a key at least 8bits in length    - For each block from i=0 while i&lt;N perform the following operations    - Repeat the following operations on block i, from r=0 while r&lt;R    - Divide the block into 2 6bit sections Lr,Rr    - Using Rr, \"expand\" the value from 6bits to 8bits.    Do this by remapping the values using their index, e.g.    1 2 3 4 5 6 -&gt; 1 2 4 3 4 3 5 6    - XOR the result of this with 8bits of the Key beginning with Key[iR+r] and wrapping back to the beginning if necessary.    - Divide the result into 2 4bit sections S1, S2    - Calculate the 2 3bit values using the two \"S boxes\" below, using S1 and S2 as input respectively.    S1  0   1   2   3   4   5   6   7    0 101 010 001 110 011 100 111 000    1 001 100 110 010 000 111 101 011    S2  0   1   2   3   4   5   6   7    0 100 000 110 101 111 001 011 010    1 101 011 000 111 110 010 001 100    - Concatenate the results of the S-boxes into 1 6bit value    - XOR the result with Lr    - Use Rr as Lr and your altered Rr (result of previous step) as Rr for any further computation on block i    - increment rThe problem is the following:He has encryped a message using Key=\"Mu\", and R=2.See if you can decipher it into plaintext.Submit your result to Larry in the format Gigem{plaintext}.Binary of ciphertext: 01100101 00100010 10001100 01011000 00010001 10000101WriteupWhile we started reading the implementation for this cipher we noticed that it was based on a Feistel networkA Feistel network is a scheme that lets you construct a block cipher efficently since it requires only a round function (that doesn’t need to be invertible) and it only involves XOR operations.The decryption is pretty straightforward. Referring to the simpleDES implementation above:On step 3, for every block before starting the rounds iteration, swap L with R. Then at the end of the R rounds, swap L and R again.You also need to reverse the key schedule for round iteration.Let’s assume you have 1 block and 3 rounds.For the encryption you use the keys K0, K1 and K2. For the decryption you will need to use K2, K1 and K0.Why?Immagine you start from 1 block of plaintext. You split it into 2 blocks L0 and R0.Now you use K0 and R0 on the round function F.This function will spit out “garbage” Z that you XOR with L0. You can now use the result as R1 and use R0 as L1.For the decryption you only need to XOR the “garbage” Z again with R1R1 = L0 ⊕ ZR1 ⊕ Z = L0 ⊕ Z ⊕ Z = LScriptsImplemented Simple DES script#!/usr/bin/env pythondef to_twelve(data):    try:        div = len(data) * len(data[0]) % 12    except:        raise Exception(\"wrongly formatted text\")            if div != 0:        raise Exception(\"text not divisible by 12\")            split = int(len(data[0]) * 1/2)    twelve = []    for i in range(0, int(len(data)/3)):        index = i*3        twelve.append(data[index+0] + data[index+1][:split])        twelve.append(data[index+1][split:] + data[index+2])    return twelvedef twelve_to_eight(data):    split = 8    eight = []    for i in range(0, int(len(data)/2)):        index = i*2        eight.append(data[index+0][:split])        eight.append(data[index+0][split:]+data[index+1][:(split/2)])        eight.append(data[index+1][(split/2):])    return eightdef ascii_to_bin(data):    return ['{:08b}'.format(ord(c)) for c in data]def bin_to_ascii(data):    t = []    for bit in range(0,len(data),8):        t.append(chr(int(data[bit:bit+8],2)))    return ''.join(t)class SimpleDES(object):    rounds = 2        sbox1 = [['101','010','001','110','011','100','111','000'],              ['001','100','110','010','000','111','101','011']]    sbox2 = [['100','000','110','101','111','001','011','010'],             ['101','011','000','111','110','010','001','100']]        def __init__(self, key, rounds=rounds):        self.key = ''.join(key)        self.rounds = rounds            def split_block(self, data):        split = int(len(data) * 1/2)        d1 = data[:split]        d2 = data[split:]        return d1, d2    def schedule_key(self, n):        self.subkeys = []        for i in range(n):            k = []            for r in range(self.rounds):                kr = \"\"                 for h in range(0,8):                    index = i*self.rounds+r + h                    kr += self.key[index%len(self.key)]                k.append(kr)            self.subkeys.append(k)    def invert_key(self, n):        self.schedule_key(n)        for i in range(n):            k = self.subkeys[i]            k.reverse()            self.subkeys[i] = k            def crypt(self, data, decrypt=False):        result = []        i = 0        for block in data:            Lr, Rr = self.split_block(block)            if decrypt:                Lr, Rr = Rr, Lr            for r in range(self.rounds):                sk = self.subkeys[i][r]                Lr, Rr = self.round(sk, Lr, Rr)            if decrypt:                Lr, Rr = Rr, Lr            result.append(Lr+Rr)            i+=1        print(result)        return twelve_to_eight(result)        def encrypt(self, data):        data = to_twelve(data)        self.schedule_key(len(data))        return self.crypt(data)            def decrypt(self, data):        data = to_twelve(data)        self.invert_key(len(data))        return self.crypt(data,True)    def round(self, subkey, L, R):        Lr = R        R = self.expand(R)        R = self.xor(R, subkey)        R1, R2 = self.split_block(R)        R1 = self.substitute(self.sbox1, R1)        R2 = self.substitute(self.sbox2, R2)        R = R1 + R2        Rr = self.xor(R, L)        return Lr, Rr        def xor(self, d1, d2):        if len(d1) != len(d2):            raise Exception(\"different length string when xoring\")        l = [str(int(a) ^ int(b)) for a,b in zip(d1,d2)]        return ''.join(l)        def expand(self, R):        return R[0]+R[1]+R[3]+R[2]+R[3]+R[2]+R[4]+R[5]            def substitute(self, sbox, block):        msb = int(block[0])        index = int(block[1:],2)        return sbox[msb][index]Got the flag script#!/usr/bin/env pythonimport simple_desciphertext = ['01100101', '00100010', '10001100', '01011000', '00010001', '10000101']key = simple_des.ascii_to_bin(\"Mu\")f = simple_des.SimpleDES(key)flag = simple_des.bin_to_ascii(''.join(f.decrypt(ciphertext)))print(\"Gigem{\" + ''.join(flag) + \"}\")"
  },
  
  {
    "title": "CodeBlue Crypto 17 - Common Modulus 1,2,3",
    "url": "/posts/CodeBlue17-Common-Modulus-1,2,3/",
    "categories": "Cryptography Engineering, CodeBlue-CTF",
    "tags": "Cryptography, Pyhton, CodeBlue-Cryptography Engineering, Math",
    "date": "2018-10-11 08:10:00 +0200",
    





    
    "snippet": "Inroduction  CodeBlue CTF 2017 - Common Modulus 1,2,3DescriptionCommon Modulus 1: Simple Common Modulus AttackCommon Modulus 2: Common Modulus Attack with common exponent divisorCommon Modulus 3: C...",
    "content": "Inroduction  CodeBlue CTF 2017 - Common Modulus 1,2,3DescriptionCommon Modulus 1: Simple Common Modulus AttackCommon Modulus 2: Common Modulus Attack with common exponent divisorCommon Modulus 3: Common Modulus Attack with common exponent divisor + message paddingWriteupThe challenge title was pretty self explanatory.textbook RSA is vulnerable to Common Modulus AttackRSA works like the following \\(c = m^e \\mod N\\)If you encrypt the same message with the same N like:\\(C_1 = M^{e_1} \\mod N\\)\\(C_2 = M^{e_2} \\mod N\\)Then \\(\\gcd(e_1, e_2)=d\\) , this means that a and b exists such that \\(e_1a + e_2b=d\\).This is usefull since:\\[\\begin{align}C_B^{s_1}*C_C^{s_2}&amp;=(M^{e_B})^{s_1}*(M^{e_C})^{s_2}\\\\&amp;=M^{e_Bs_1}*M^{e_Cs_2}\\\\&amp;=M^{e_Bs_1+e_Cs_2}\\\\&amp;=M^1\\\\&amp;=M\\end{align}\\]In the case where \\(e_1\\) and \\(e_2\\) don’t share any factor, \\(\\gcd(e_1, e_2)=1\\) so \\(M^d = M^1 = M\\) .In the case where \\(e_1\\) and \\(e_2\\) share some factors, we end up with \\(M^d\\). Common Modulus 1 was the first easy case.In Common Modulus 2 both the exponents were multiplied by \\(3\\), so \\(d=3 then M^d=M^3\\)Luckily our \\(M^3\\) is smaller than our N so we can retrive the flag by applying the cube-root.In Common Modulus 3, the greatest common divisor is \\(17\\) and unfortunately \\(M^{17}&gt;N\\).We need to remove the padding from M until \\(M^{17} &lt; N\\) then take the 17th-root as before.The message/flag is padded with the following code:flag = key.FLAG.encode('hex')while len(flag) * 4 &lt; 8192:  flag += '00'FLAG = long(flag[:-2], 16)len(FLAG) should be 2046, the previous flags were CBCTF{&lt;32_char_here&gt;} so converted in hex we have len(flag) = 78\\[2046-78=1968\\]Adding 00 to an hex number it’s the same as multiplying by \\(2^4\\),so we need to multiply the padded M by \\(2^{-4}\\) to remove all the 00Let \\(d=17\\) and \\(i=1968\\), retrive \\(M\\) with\\(\\begin{align}M''&amp;=C_1^{a}*C_2^{b}\\\\M'&amp;=M''*2^{-d*4*i}\\\\M&amp;=\\sqrt[d]{M'}\\qquad\\end{align}\\)Pyhton Scriptfrom libnum import *def common_modulus(e1, e2, c1, c2, N):    # Extended Euclidean algorithm    a, b, d = xgcd(e1,e2)        # Invert negative factor    if b &lt; 0:        c2 = invmod(c2, N)        b = -b    if a &lt; 0:        c1 = invmod(c1, N)        a = -a        # Get the message (c1^a * c2^b) % N    m = (pow(c1,a,N) * pow(c2,b,N)) % N    return [m, a, b, d]    def pad(m, d, i, N):    if -d*4*i &lt; 0:        f = pow(invmod(2, N), d*4*i, N)    else:        f = pow(2, -d*4*i, N)    return m * f % N## Common Modulus 1N = 791311309087374588934274354916349141233150778762086315374343850126808782284294921228110916322178898551691669133101997907127587121520288166574468605214516304122927763843434653215681360872523253290766297044510870617745122997739814947286892376888776319552516141136363673315815999597035068706744362048480852074989063152333880754375196551355543036200494314973628012006925154168913855587162465714207917714655810265293814697401062934881400969828166519415465439814160673468968009887672546243771190906300544375962002574334018175007498231632240021805593635057187842353840461973449205839419195826992169177108307004404365745462706797969436718212150888171299620800051183755681631250040936288149592343890616920153400691102933966724025765766418338452595218861582008026186067946508221264938736562082192890727980844444978081110599714993030990031363457184296168457089953510500474033234298252385232725393194957086065274263743550741242453140557383981358497807318476777558208795816650619401057283873302725816795298930817307745973266335447938091252055872816232968635169429875153933553733116356920185396530990560434510949092154539711124052490142742567527833751624924993906099869301505096094512729115132147653907827742334805918235749308541981388529841813147Le1 = 813647c1 = 767202255403494641285723819543278226263601155898823605265497361830705668240032418501494959141449028517100422081272691883369257107388411439611318808983979122090486252578041006071999581282663085495058515958745546211668701835250122032715473014598395050184702983368667972803718169481809394565706175141425650370279775233813674442957760484285820381853600163980060348710028919659329781877491724136976028815641232407109144869660767954119268355348405951052583739555066569345526640029961785158127382321111833599691079949415049786723663210542733655554868327542833053024595895523192888118675763242352407948643537985861448788568550308481655116845634952516676905251579084404308314639717162526798451410767058423619677212069270398132021729448047980766312818656065369023093123058422620085273728481545680423266197847937925342263870309939913221308330842487685037638837340238355192125668409039255551545407800543798158964963358868702135730305156935767426581823180696819366253148799571923731323928995477390559418822575259531941023518182807739949726026157027426545624061195471888653152768495272113769751755053321333829345939391638863918920798107792346015224509118930143010726156407828938941341788657835191853473698010478888928860138978235297618195944868175e2 = 846359c2 = 393205642868817442649216793359718556278406137459770244761832906195960432918468617731069456704644789806507809829093842629745066759599286729538728368882491382997337611417441529220397067642218119525968897551289230558627870154984979444195757677411673096443476021362319325097662392808170632471553717355895219405644518503783235536597143112954291157798713583737689125917709618182162360535659223966858707155741267214975141963463832314566520144602105237041672437684177707624423211972004800873375670613148140256099552724408192217550331987310558991433383571470532995856778764797540637679226825577553396934734325550293550389623919904744913990305949697308222046594160302362669510242921299755255790640101006152269619965560742243168099219363626217512940995615730916134775134764069912120583282148219405178065222313607957426887495658080497917440100549199528894874905968298614233827155712422019324710018755792249855902168601927285980197334672067920857960628679370550895555840658121626134216719240409691397735762685349162277111815727100169755960553688569326705249270662470879197234836585418835845237231721910938341557726245940031873345666571751867755961294973426045629909899256967038811807893676700888551318830676356324765330202998096318754445585853694m, _, _, _ = common_modulus(e1,e2,c1,c2,N)flag = n2s(m)print(flag)## Common Modulus 2N = 691611766208546073444876122261067788277978858453710639029761974358666489171591889808344592871468081368348731289584873825685836699513369087940744233044470468106283756269016888690397802087612562650740690626844050981638158798650899164329024889012339813251634342169796374490173324858177655412520581064091323105709703802894635752243504165527728325493775585018099572491218738859140069209745383085972126419677929983854492018948495162457428459536088314487922683148031388611849013227501962458386817851194913551405843074740308192841259015955432216658418219471365781271743026881045054161177699500233983945284463060091084401032681620162554495490307966608011765399197534175588394769839991952726269105973546086964385977836193216093842605576347580465390858378577913173391209728199847916944392685608959720919745441534152140791433228642857247821519585327091864890122871765266988285510728943279970135846908966516130597249552710186071954611133294079017500030355232895541367427153922527925908108643934213023557398363684188823565535815365161748782796247844503993809352854741573950620787090272760236473228652960605730173150252619759400890068298838592790770868307280012495168740250977525199965477849089021924445456338550258621310346872587368865023459114279Le1 = 2623119c1 = 632613645684838434911920364870092246688638723680203743297038042884981435531349983627632652213126007404455112992754038899192740232209237012089852184466576496173356903126767617531366105427616049893559911396536574555008451239827427140619373005107923039458285095437111146013805698400274937791209388463040761234346114146112603113513874269976957472698342250573902102976387047390228485927254752372525379266486917620487089416581168720140744193600912161065888758451629009978676721731074043142666019127528370181044741033938879227651226413524178992155234346229899043794846119210274959231350300191718278291314079326011260972911790929707654859407903619102516710246683375658271085356783673232677699444921875427077745087507202504075374873842972977165904031632108921391219453633100007509368853543202918527396858214941532156620908283394786740941868393377733920317480973184132461984594109692489226477402338664642727766514992506288377119275635222078018270479534265371971469799345627297451492177595572561618185463142728664331779856911512823762928116551034186671353283417747535010208121962539603383913657773795358612010178381857101029638404248669376029927680328805839410427459248430136708902815920536603541943356116875656311481908672896225539754812052984e2 = 2611101c2= 473583830101449207063655453483957320801977763405664178108962387145963115641321631378723122470718049239150183483107837540062110255460217493574236417576528210993551734521104360323008425196350719034294427914294044848231276934402896045785500160974092767601908407706594433190832523140982335688121038712802163776950422665847149664034820576774873956120202470663588902529914328392634164212558025176982387474287314624421143326789371057668708456922968762564019631616913937820209470604081356673188045257490667304640155390478645279862586730343779998826931285683980941686981775369499484033439920659579124275957233449431588512697916708510428626881790592757578867152025501459202793986322020476004209777449674143157280081483085868896558215825742742029607229809248023263081810931655981810534293127835168642962477010095223356972141559004635008185531900175232541978761179342338914489553003329293031284557554252476291770973145365678145226167965362251186233138510776436645583796590010200995100899736056399413460647507781994189935869541735701599175369334170081795310585938471394672279359692859881857399434361716843681313191143289947464231132723256066979526475873327590657111481299295002695482778491520250596998683754980263059514032256777144682239680031331m, _, _, d = common_modulus(e1,e2,c1,c2,N)m3 = nroot(m, d)flag = n2s(m3)print(flag)## Common Modulus 3N = 968303207185607392933798782387689522656147561712795299283882287440997111985337043607347852676675972362918419582716466493901827460706450708953088746657795254328535683015238473202723829157430427867421087226189467195646844668802837819623414935635764658530099227590830741510249221895574884771436827770318305551317176839494597881542410308108175111834839215570956517340899194288784858826431213509713952528866287993390613948062491441610747107348648602379185114554723774040662560407455840832110271813933032624805073788024993067973148443925303253795470847563536231692617336003345253420781728080545107013979989225215051608062044642404350318860297552684325830122651066498471494796197140830046228424107290568844093340204267361082742078820287806283549564233943675107998076566543352390069511549956964748416720763513751358887667167332126080075430087233981966806427580520370257808050907653401104327326631097877139317246068499669501296942050536122626128764679345686334508003799157031148558906404519754488943090430614449734145826672306815863417618237639635345018467258462900064790890385390508718602990300495726938127324285656651880960536234978827321187318512537049899040749483345012221361131129792213254633506153185302186568540749980375628514235030855807045314709882496753074374605804287524700316006092896795420448048753563680014346711220542647330945566829248331838201572696721484611259634434782075831402355726031168909134250473545733318680648535591393583591753681796583867361941369612638709097786386797652973805166862674686551290098101135899770942208220247225222462958306451292887778107274202080862990165408064372884914158792725013116440247234948462221463395579778209416361358418236648009499845276591742121866289571920719060295618309551857388542560147442529378101156132620061921583469878917947302508627776695573047820182057510772384875135795550437710313658255283287862276198618250884260442348343850066240114035518636573845052654416580159067713183299304803538785632234238046467384672538122045063632667757962772674939972792679509851714820791391542209183895101043149418861154827906828713093460640624918161442498432261330207213585143333235283987920999836862245963629061098253465280043891903366631221500293216287006734530837307036369234284523611530022158837165369780256375911835104289853776157817361701638375344905311830460059612259798600223588322136072986423796319913187356442617636479007538166981641749486826645166479345057550622122298936583765413411917302326827553940008588471939786317Le1 = 13218197c1 = 421111161283346431452404838872906910488956231402567019627078538397015129219548039141380131693083805603634832115136344104821561027925864923901767159809798556819390401416411855168293007844311613426948800208007055064348403326803934387258467126612219000171854953396242427891713082121012531213725355828779993888182933907101893044052692649728535361366924432892126370724588453260805681821935597271080255619110465374127164951502400983809536186925456642086304791751551216044579863129291165009342909475237361181743987301745314378124693429484474503217504889965795409106282650296184945237152875186651795552666842345066169360660546054986708172417429052514059615434084086154415920830883055729609108788179781445658162049137989591033198225687070565856609516100367268190340309308157085784134411282761584130225746032198957351227779773001865341915642873414205377145922729731246073639219795924517066513774579919237687232502798978463575009663263447306363691670476046609459059167879832079562689979943552446917015778003739858532004479603764374411135699895655736013845369551111690464128448955486337191304960262873891918387298035244888743768954328136862535082300010994461970837930794524673040694310506226189740828318579439950518115967189869637345638498098713092489244636082588805772227797143449747153355341250697133905040459624514982099584435140538668878747129925880019957973864264834954951976218071371679757509297492047186840975743403271896047156768874314108910566561868784522463064748746223313798316236978642468003218086919263188950066989044210829301678555320837086377545741001736801163743516580353549217680694256032377932133575488109549594325464409000682442042651791171660390153162096538381581148625792618196174157168997050557100450557288143739840824092541232969307054965994887340364612034225310418659933594966854225109483090892335755747449339249960596843266176465016510244036725441439565001070917883074011690676911331738356675397441288471244334501091751395240775991013123686801229872759306547212076067886148629332008410208267030715989530663720054487572883736818402878156320070866728567321649066842627412668340251628750512807830348760198570727092664649603270152943231283098179852700308804060616603604109118233213539629764618927518884532667481665405755714542980086417296700138731812815602896287231173509006149715343922041354056256194681983557852276963918040964106582078239501915086320391282791023780691061950154312894926940866878046518974877055347229774579384836298084254309194742164500782e2 = 13325773c2 = 905336011260893181451937420601175770518313987534058470576409049452599974940736949020892631904955374029696187995214208522797070994604711663756814784706053753391830801248808142181434422224620348115969075398677162880328104668870990618955018212918253536803780269490731174871303579036880145367252409300321511403369634435527150000969450834032455903281526350857234024199221097951905683106432984567192925721856154512618509568221546898136983740670694848845816274649037002810596080076911851084982546841069002779200879395931456796911067433329924739943299552475793965462348342813683729525726622940637841204356613245154725191731818570068876251576706021876289420301350487275708440713574921631267131651109260124766475594710481161866254565495750886839979733888772439130815149472846472765436552529628205718020374215877005469575372812773398343007234021177110808440750777736752300216949812950208548770769356889084232841311299404061610926387440620373137543532240294565244268885021138356121583352086433040479579285669028705571672002026293450745788592556823683194951826864141604029265650908715426822940827714455571796485962047146479512064410497475912291097113335318214286537554114706858926411912595063427662813512257156617697572638072509013871077829931469009241562237896598800666350337578826848041056097241547835195327840625894306586665539851835002956883837883293039313345815320389859457247452362675082429215289259947007386622301346393036750250168159297672722825807855637539796284414040339895615478904699195785762873300869004533530925681372154050324943727448464697359515536114806520493724557784204316395281200493439754546212305945038548703862153513568552164320556554039878316192239576925690599059819274827811660423411125130527352853059068829976616766635622188402967122171283526317336114731850274527784991508989562864331372520028706424190362623058696630974348010681878756845430600722349325469186628612347668798617024215127322351935893754437838675067920448401031834465304168738463170328598024532652790234530162187677742373772610227011372650971705426850962132725369442443471111605896253734934335599889785048210986345764273409091402794347076211775580564523705131025788768349950799136508286891544854890654019681560870443838699627458034827040931554727774022911060988866035389927962128604944287104134091087855031454577661765552937836562030914936714391213421737277968877508252894207799747341644008076766221537325719773971004607956958298021339118374168598829394997802039272072755111105775037781715m, _, _, d = common_modulus(e1,e2,c1,c2,N)for i in range(1900, 2048):    m_unpadded = pad(m, d, i, N)    m17 = nroot(m_unpadded, d)    flag = n2s(m17)    if 'CTF{' in flag:        print(flag)        break Solution` Flag is Captured ` »CBCTF{6ac2afd2fc108894db8ab21d1e30d3f3}CBCTF{d65718235c137a94264f16d3a51fefa1}CBCTF{b5c96e00cb90d11ec6eccdc58ef0272d} "
  },
  
  {
    "title": "QIWI - Crypto 400_1",
    "url": "/posts/Crypto-400_1/",
    "categories": "Cryptography Engineering, Qiwi-CTF",
    "tags": "Cryptography, Pyhton, Qiwi-Cryptography Engineering",
    "date": "2018-09-05 08:10:00 +0200",
    





    
    "snippet": "Inroduction  Qiwi-Infosec - Crypto 400_1 based on Coppersmith’s attack.DescriptionMessage m has been encrypted by RSA with exponent e=3 for three users. Users have been used different modulus (n1, ...",
    "content": "Inroduction  Qiwi-Infosec - Crypto 400_1 based on Coppersmith’s attack.DescriptionMessage m has been encrypted by RSA with exponent e=3 for three users. Users have been used different modulus (n1, n2, n3 respectively). As a result 3 ciphertexts have been obtained (c1, c2, c3 respectively). Decrypt the message. The flag is a sensible text.The given n1, n2, n3, c1, c2, c3 are reported in the scriptSolutionThis crypto challenge is based on the Hastad’s broadcast attack.So by implementing the Chinese Remainder Theorem we could solve this easilyThe python script FTWThis is a simple crypto challenge on the Diffie-Hellman key exchange protocol.#!/usr/bin/env pythone=3n1=95118357989037539883272168746004652872958890562445814301889866663072352421703264985997800660075311645555799745426868343365321502734736006248007902409628540578635925559742217480797487130202747020211452620743021097565113059392504472785227154824117231077844444672393221838192941390309312484066647007469668558141n2=98364165919251246243846667323542318022804234833677924161175733253689581393607346667895298253718184273532268982060905629399628154981918712070241451494491161470827737146176316011843738943427121602324208773653180782732999422869439588198318422451697920640563880777385577064913983202033744281727004289781821019463n3=68827940939353189613090392226898155021742772897822438483545021944215812146809318686510375724064888705296373853398955093076663323001380047857809774866390083434272781362447147441422207967577323769812896038816586757242130224524828935043187315579523412439309138816335569845470021720847405857361000537204746060031c1=64830446708169012766414587327568812421130434817526089146190136796461298592071238930384707543318390292451118980302805512151790248989622269362958718228298427212630272525186478627299999847489018400624400671876697708952447638990802345587381905407236935494271436960764899006430941507608152322588169896193268212007c2=96907490717344346588432491603722312694208660334282964234487687654593984714144825656198180777872327279250667961465169799267405734431675111035362089729249995027326863099262522421206459400405230377631141132882997336829218810171728925087535674907455584557956801831447125486753515868079342148815961792481779375529c3=43683874913011746530056103145445250281307732634045437486524605104639785469050499171640521477036470750903341523336599602288176611160637522568868391237689241446392699321910723235061180826945464649780373301028139049288881578234840739545000338202917678008269794179100732341269448362920924719338148857398181962112def chinese_remainder(n, a):    sum = 0    prod = reduce(lambda a, b: a*b, n)    for n_i, a_i in zip(n, a):        p = prod / n_i        sum += a_i * mul_inv(p, n_i) * p    return sum % proddef mul_inv(a, b):    b0 = b    x0, x1 = 0, 1    if b == 1: return 1    while a &gt; 1:        q = a / b        a, b = b, a%b        x0, x1 = x1 - q * x0, x0    if x1 &lt; 0: x1 += b0    return x1def find_invpow(x,n):    \"\"\"Finds the integer component of the n'th root of x,    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.    \"\"\"    high = 1    while high ** n &lt; x:        high *= 2    low = high/2    while low &lt; high:        mid = (low + high) // 2        if low &lt; mid and mid**n &lt; x:            low = mid        elif high &gt; mid and mid**n &gt; x:            high = mid        else:            return mid    return mid + 1flag_cubed=chinese_remainder([n1,n2,n3],[c1,c2,c3])flag=find_invpow(flag_cubed,3)print \"flag: \",hex(flag)[2:-1].decode(\"hex\")` Flag is Captured ` » theoretical_computer_scientist_johan_torkel_hastad"
  },
  
  {
    "title": "QIWI - Crypto 300_1",
    "url": "/posts/Crypto-300_1/",
    "categories": "Cryptography Engineering, Qiwi-CTF",
    "tags": "Cryptography, Pyhton, Qiwi-Cryptography Engineering",
    "date": "2018-08-12 08:10:00 +0200",
    





    
    "snippet": "Inroduction  Qiwi-Infosec - Crypto 300_1 shared key in decimal.DescriptionAlice, Bob, and Cameron want to get shared key by Diffie-Hellman method. Their public keys respectively are g^a mod p, g^b ...",
    "content": "Inroduction  Qiwi-Infosec - Crypto 300_1 shared key in decimal.DescriptionAlice, Bob, and Cameron want to get shared key by Diffie-Hellman method. Their public keys respectively are g^a mod p, g^b mod p, g^c mod p. Will Alice and Bob be able to get shared key without Cameron’s private key? The flag is the first 20 digits of the shared key in decimal formp:8986158661930085086019708402870402191114171745913160469454315876556947370642799226714405016920875594030192024506376929926694545081888689821796050434591251;g: 6;a: 230;b: 250;g^c:5361617800833598741530924081762225477418277010142022622731688158297759621329407070985497917078988781448889947074350694220209769840915705739528359582454617;SolutionThis is a simple crypto challenge on the Diffie-Hellman key exchange protocol.In this scenario we have 3 user that need to agree on a shared key and we need to calculate it.The formula for the shared key is: g^abc mod p.We have Alice and Bob private key (a and b), but we have only Cameron public key g^c mod pWe can’t compute directly (((g)^a)^b)^c mod p but we can compute the shared key this way:((g^c)^a)^b mod pThe python-sage script that get the flag#!/usr/bin/env sage -pythonp=8986158661930085086019708402870402191114171745913160469454315876556947370642799226714405016920875594030192024506376929926694545081888689821796050434591251g=6a=230b=250gc=5361617800833598741530924081762225477418277010142022622731688158297759621329407070985497917078988781448889947074350694220209769840915705739528359582454617gca = (gc**a) % pgcab = (gca**b) % pprint \"flag: \", str(gcab)[:20]` Flag is Captured ` » 38058349620867258480"
  },
  
  {
    "title": "QIWI - Crypto 100_1",
    "url": "/posts/Crypto-100_1/",
    "categories": "Cryptography Engineering, Qiwi-CTF",
    "tags": "Cryptography, Pyhton, Qiwi-Cryptography Engineering",
    "date": "2018-07-17 08:10:00 +0200",
    





    
    "snippet": "Inroduction  Qiwi-Infosec - Crypto 100_1 cipher text need to be decoded to read the secret message .DescriptionWe got a cipher text that was five lines long and consisted of underscores and numbers...",
    "content": "Inroduction  Qiwi-Infosec - Crypto 100_1 cipher text need to be decoded to read the secret message .DescriptionWe got a cipher text that was five lines long and consisted of underscores and numbers from 1 to 5.Chipher TextThe following cipher was given: 52112515_4535_331534 442315_321144422453_231143_543445 213431313452_442315_5223244415_411112122444 2533341325_2533341325_331534 442315_21311122_2443_442315_4423244214_31243315SolutionBy trying a lot of different decoders eventually found that this is a Polybius-Cipher , Using Cryptii Polybius square  as web based decoding web or you can use pyhton script that i wrotePython decoding funcationThe original square according to Wikipedia is as follows:                   1      2      3      4      5                  1      a      b      c      d      e              2      f      g      h      i/j      k              3      l      m      n      o      p              4      q      r      s      t      u              5      v      w      x      y      z      Each character is presented with two numbers. The first number shows the row and the second number shows the column of the character.ciphers = ['52112515_4535_331534','442315_321144422453_231143_543445','213431313452_442315_5223244415_411112122444','2533341325_2533341325_331534','442315_21311122_2443_442315_4423244214_31243315']matrix = [['a', 'b', 'c', 'd', 'e'],['f', 'g', 'h', 'i', 'k'],['l', 'm', 'n', 'o', 'p'],['q', 'r', 's', 't', 'u'],['v', 'w', 'x', 'y', 'z']]plain = []for c in ciphers:words = c.split('_')for word in words:for num in range(0, len(word), 2):y = int(word[num])x = int(word[num + 1])plain.append(matrix[y - 1][x - 1])plain.append('_')plain[len(plain) - 1] = '\\n'print ''.join(plain)` Cypher Texg is  `WAKE_UP_NEOTHE_MATRIX_HAS_YOUFOLLOW_THE_WHITE_QABBITKNOCK_KNOCK_NEOTHE_FLAG_IS_THE_THIRD_LINE` Flag is Captured ` » FOLLOW_THE_WHITE_QABBIT"
  },
  
  {
    "title": "Reverse Engineering Training",
    "url": "/posts/Reverse-Engineering-Training/",
    "categories": "Reverse Engineering, CT-CTF",
    "tags": "linux binary, CT-Reverse Engineering, C++",
    "date": "2018-07-05 09:27:00 +0200",
    





    
    "snippet": "Inroduction  Cyber Talents - training reverse engineering ahram canadian competition.Descriptionx64 stripped linux binary file given file called training with description of “ training, keep traini...",
    "content": "Inroduction  Cyber Talents - training reverse engineering ahram canadian competition.Descriptionx64 stripped linux binary file given file called training with description of “ training, keep training.” Reverse it to get the flagFileFor downloading  , Visit  training .SolutionThe file is a x64 stripped linux binaryAt running, it reads from stdin and just prints back what I writeSo let’s load it to IDAI also used HexRays decompiler to get the pseudo-code of the functionsFor the main function we have__int64 __fastcall main(__int64 a1, char **a2, char **a3){  _QWORD *v3; // rax  char v4; // bl  __int64 v5; // rax  char v7; // [rsp+Fh] [rbp-A1h]  char v8; // [rsp+10h] [rbp-A0h]  char v9; // [rsp+30h] [rbp-80h]  char v10; // [rsp+50h] [rbp-60h]  char v11; // [rsp+70h] [rbp-40h]  unsigned __int64 v12; // [rsp+98h] [rbp-18h]  v12 = __readfsqword(0x28u);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v8, a2, a3);  sub_130A();  while ( 1 )  {    v3 = std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v8);    if ( !std::basic_ios&lt;char,std::char_traits&lt;char&gt;&gt;::operator bool(v3 + *(*v3 - 24LL)) )      break;    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v9, &amp;v8);    sub_13DB(&amp;v10, &amp;v9);    v4 = 0;    if ( sub_1A6C(&amp;v10, &amp;unk_2046A0) )    {      std::allocator&lt;char&gt;::allocator(&amp;v7);      v4 = 1;      std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v11, \"correct\", &amp;v7);    }    else    {      std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v11, &amp;v8);    }    v5 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cout, &amp;v11);    std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v11);    if ( v4 )      std::allocator&lt;char&gt;::~allocator(&amp;v7);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v10);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v9);  }  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v8);  return 0LL;}Here we have a C++ program, so we have other functions to allocate memory and copy dataFor now we can understandstd::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_stringto be a data copy mechanism that copies the data from the second parameter to the first oneAndstd::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_stringto be a memory free mechanismFirst let me explain the code line by line  First it defines the different used variables and their types  Assigns v12 to be a 8-byte (qword) address at offset 0x28 from the register segment FS (not important for us)  a2 and a3 are the parameters of the main function so this should be a default operation (not important for us)  Executes the function sub_130A  Initiates an infinity loop (can be broken from inside)  Copies the address of pointer v8 to the address of the stdin (now any input data will be at pointer v8)  Checks if the previous operation returned properly if not it will break (not important for us)  Copies the address of v8 to the address of v9 (now any input data will be at pointer v9)  Executes sub_13DB with two pointers v10 and v9 (our input data)  Assigns v4 to be 0  Executes sub_1A6C with two pointer &amp;v10 and unknown pointer at 0x2046A0 and check for the return  If returned a non-zero value it allocates some memory and gives its address to pointer v7 and assigns v4 to 1  Copies the string correct to memory of v11  If returned zero, it copies data from v8 (our input data) to pointer v11  Copies address of v11 (correct or our input data) to be the address of stdout (prints &amp;v11)  Prints new line  Free memory of v11  Free memory of v7 if v4 is non-zero (or when the previous condition is true)  Free memory of v9, v10, v8, and returnSo simply it will read our input, make some check on it, if it passed it will print ‘correct’ if not it will print our inputFor the checking function sub_1A6C we have_BOOL8 __fastcall sub_1A6C(__int64 a1, __int64 a2){  __int64 v2; // rbx  __int64 v3; // r12  __int64 v4; // rbx  __int64 v5; // rax  _BOOL8 result; // rax  v2 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::size(a1);  result = 0;  if ( v2 == std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::size(a2) )  {    v3 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::size(a1);    v4 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::data(a2);    v5 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::data(a1);    if ( !sub_18BF(v5, v4, v3) )      result = 1;  }  return result;}And for sub_18BFint __fastcall sub_18BF(const void *a1, const void *a2, size_t a3){  int result; // eax  if ( a3 )    result = memcmp(a1, a2, a3);  else    result = 0;  return result;}Which seems to be a simple comparison function that makes sure the data and the size of the two pointers are the sameSo now we need to know the data at the pointer unk_2046A0, but when I tried to dump it it was not initialisedPointer unk_2046A0 will be initialised at the runtime by some functionTo know where it will be filled with data in ida you can jump to its x-refernces (right click–&gt;jump to xref)To find that it will be initialised by the function sub_178E at which we haveunsigned __int64 __fastcall sub_178E(int a1, int a2){  char v3; // [rsp+17h] [rbp-19h]  unsigned __int64 v4; // [rsp+18h] [rbp-18h]  v4 = __readfsqword(0x28u);  if ( a1 == 1 &amp;&amp; a2 == 0xFFFF )  {    std::ios_base::Init::Init(&amp;unk_204680);    __cxa_atexit(&amp;std::ios_base::Init::~Init, &amp;unk_204680, &amp;off_204008);    std::allocator&lt;char&gt;::allocator(&amp;v3);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(      &amp;unk_2046A0,      \"IQHR}nxio_vtvk_aapbijsr_vnxwbbmm{\",      &amp;v3);    std::allocator&lt;char&gt;::~allocator(&amp;v3);    __cxa_atexit(      &amp;std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string,      &amp;unk_2046A0,      &amp;off_204008);    sub_19B4(&amp;unk_204260);    __cxa_atexit(sub_261E, &amp;unk_204260, &amp;off_204008);  }  return __readfsqword(0x28u) ^ v4;}From the code we know that it will copy the string IQHR}nxio_vtvk_aapbijsr_vnxwbbmm{ to our unknown pointerNow I am pretty sure that the function sub_13DB is the encryption function that takes two pointers &amp;v10 and &amp;v9 (our input) and it will encrypt our input and copy the result to &amp;v10 to be checked again by sub_1A6CNow for sub_13DB we have__int64 __fastcall sub_13DB(__int64 a1, __int64 a2){  int v2; // ebx  char *v3; // rax  signed int v4; // eax  char *v5; // rax  char *v6; // rax  __int64 v7; // rbx  int i; // [rsp+14h] [rbp-1Ch]  int v10; // [rsp+18h] [rbp-18h]  for ( i = 0; *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i); ++i )  {    v2 = *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);    v10 = v2 + *sub_1A4C(&amp;unk_204260, i);    v3 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);    if ( sub_1929(*v3) )    {      v4 = 122;    }    else    {      v5 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);      if ( sub_194C(*v5) )        v4 = 90;      else        v4 = *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);    }    while ( v10 &gt; v4 )      v10 -= 26;    if ( *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i) == 123 )    {      LOBYTE(v7) = 125;    }    else if ( *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i) == 125 )    {      LOBYTE(v7) = 123;    }    else    {      v6 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);      if ( sub_18FA(*v6) )        LOBYTE(v7) = v10;      else        v7 = *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i);    }    *std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i) = v7;  }  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(a1, a2);  return a1;}You can understand :std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a2, i)to be just (&amp;a2+i) which is a2[i]For sub_1A4C, sub_1929, sub_194C, sub_18FA, they are just small checking functionsAlso we have this pointer unk_204260 which is also not initialised, jump to its x-references to find out the function that will fill itThis function is sub_130A which is hard to be reversed so we will debug (source code debugging) it to get the data at this pointerI set a break point at the line after the line it used inI used ida x64 remote linux debugger server on ubuntu x64Dumped the data from it with GetManyBytes idapython api functionThe dumped data was['\\x03\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x1d\\x00\\x00\\x00\\x1f\\x00\\x00\\x00%\\x00\\x00\\x00)\\x00\\x00\\x00+\\x00\\x00\\x00/\\x00\\x00\\x005\\x00\\x00\\x00;\\x00\\x00\\x00=\\x00\\x00\\x00C\\x00\\x00\\x00G\\x00\\x00\\x00I\\x00\\x00\\x00O\\x00\\x00\\x00S\\x00\\x00\\x00Y\\x00\\x00\\x00a\\x00\\x00\\x00e\\x00\\x00\\x00g\\x00\\x00\\x00k\\x00\\x00\\x00m\\x00\\x00\\x00q\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\x83\\x00\\x00\\x00\\x89\\x00\\x00\\x00\\x8b\\x00\\x00\\x00\\x95\\x00\\x00\\x00\\x97\\x00\\x00\\x00\\x9d\\x00\\x00\\x00\\xa3\\x00\\x00\\x00\\xa7\\x00\\x00\\x00\\xad\\x00\\x00\\x00\\xb3\\x00\\x00\\x00\\xb5\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xc1\\x00\\x00\\x00\\xc5\\x00\\x00\\x00\\xc7\\x00\\x00\\x00\\xd3\\x00\\x00\\x00\\xdf\\x00\\x00\\x00\\xe3\\x00\\x00\\x00\\xe5\\x00\\x00\\x00\\xe9\\x00\\x00\\x00\\xef\\x00\\x00\\x00\\xf1\\x00\\x00\\x00\\xfb\\x00\\x00\\x00']the fact that these bytes will be casted to be int32 and every int32 is 4 bytes, also we know that the bytes are in little-endian format so a bytes array like '\\x03\\x00\\x00\\x00' is just 0x03 and so onSo for now we have our key array to be[0x03,0x05,0x07,0x0b,0x0d,0x11,0x13,0x17,0x1D,0x1F,0x25,0x29,0x2B,0x2F,0x35,0x3B,0x3D,0x43,0x47,0x49,0x4F,0x53,0x59,0x61,0x65,0x67,0x6B,0x6D,0x71,0x7F,0x83,0x89,0x8B,0x95,0x97,0x9D,0x0A3,0xA7,0xAD,0xB3,0xB5,0xbf,0xc1,0xc5,0xc7,0xd3,0xdf,0xe3,0xe5,0xe9,0xef,0xf1,0xfb]So for this encryption function we have the output which is IQHR}nxio_vtvk_aapbijsr_vnxwbbmm{ and the keyThis is a kind of a rotation encryption function so I assumed that I will got the right flag if just passed the output as input again and so on to get the write flagAlso I rewrited it in python so as we can decrypt our stringI made this scriptkey = [0x03,0x05,0x07,0x0b,0x0d,0x11,0x13,0x17,0x1D,0x1F,0x25,0x29,0x2B,0x2F,0x35,0x3B,0x3D,0x43,0x47,0x49,0x4F,0x53,0x59,0x61,0x65,0x67,0x6B,0x6D,0x71,0x7F,0x83,0x89,0x8B,0x95,0x97,0x9D,0x0A3,0xA7,0xAD,0xB3,0xB5,0xbf,0xc1,0xc5,0xc7,0xd3,0xdf,0xe3,0xe5,0xe9,0xef,0xf1,0xfb]def enc(inp):    inp = list(inp)    for i in range(len(inp)):        current_char = ord(inp[i])        v17 = ord(inp[i]) + key[i]        if current_char &gt; 96 and current_char &lt;= 122:            v6 = 122        else:            if (current_char &gt; 96 and current_char &lt;= 122 or current_char &gt; 64 and current_char &lt;= 90) and not (current_char &gt; 96 and current_char &lt;= 122):                v6 = 90            else:                v6 = current_char        while v17 &gt; v6: v17 -= 26        if current_char == 123:            v12 = 125        else:            if current_char == 125:                v12 = 123            else:                if current_char &gt; 96 and current_char &lt;= 122 or current_char &gt; 64 and current_char &lt;= 90:                    v12 = v17                else:                    v12 = current_char        inp[i] = chr(v12)    return ''.join(inp)flag=\"IQHR}nxio_vtvk_aapbijsr_vnxwbbmm{\"while True:    if \"FLAG\" in flag:        print(flag)        break    flag = enc(flag)` Flag is Captured ` » {well_keep_training_yourself}"
  },
  
  {
    "title": "Reverse Engineering - Cloak and Dagger",
    "url": "/posts/cloak-and-dagger-reverce/",
    "categories": "Reverse Engineering, CT-CTF",
    "tags": "C++, CT-Reverse Engineering",
    "date": "2018-06-01 08:10:00 +0200",
    





    
    "snippet": "Inroduction  Cyber Talents - Cloak and dagger reverse engineering ahram canadian competition.DescriptionDot net binary file given as excutable file called cloak and dagger with description of “ Ope...",
    "content": "Inroduction  Cyber Talents - Cloak and dagger reverse engineering ahram canadian competition.DescriptionDot net binary file given as excutable file called cloak and dagger with description of “ Open The right file to get the flag “ Reverse it to get the flagFileFor downloading excutable file , Visit  Cloak And Dagger.exe .SolutionThe file is .NET binary (you may use Detect It Easy to determine the type of a binary)On running it, it just lets you select a file and makes a messagebox with You have the wrong file!So let’s load it to dnSpyAt the decompiled class form1 there are two methodspublic static string HexStr(byte[] p)\t\t{\t\t\tchar[] array = new char[p.Length * 2 + 2];\t\t\tarray[0] = '0';\t\t\tarray[1] = 'x';\t\t\tint i = 0;\t\t\tint num = 2;\t\t\twhile (i &lt; p.Length)\t\t\t{\t\t\t\tbyte b = (byte)(p[i] &gt;&gt; 4);\t\t\t\tarray[num] = (char)((b &gt; 9) ? (b + 55) : (b + 48));\t\t\t\tb = (byte)(p[i] &amp; 15);\t\t\t\tarray[++num] = (char)((b &gt; 9) ? (b + 55) : (b + 48));\t\t\t\ti++;\t\t\t\tnum++;\t\t\t}\t\t\treturn new string(array);\t\t}Which just converts a byte array into hex value ‘a’ —&gt; ‘0x61’ (you can use https://dotnetfiddle.net/ or the interactive c# plugin at dnSpy to test c# code snippets)Also we haveprivate void button1_Click(object sender, EventArgs e)\t\t{\t\t\tif (this.openFileDialog1.ShowDialog() == DialogResult.OK)\t\t\t{\t\t\t\tstring fileName = this.openFileDialog1.FileName;\t\t\t\ttry\t\t\t\t{\t\t\t\t\tstring b = \"FF0003060C1204121212000100C40307\";\t\t\t\t\tBinaryReader binaryReader = new BinaryReader(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.None));\t\t\t\t\tbinaryReader.BaseStream.Position = 0L;\t\t\t\t\tbyte[] p = binaryReader.ReadBytes(256);\t\t\t\t\tbinaryReader.Close();\t\t\t\t\tstring a = string.Concat(new string[]\t\t\t\t\t{\t\t\t\t\t\tForm1.HexStr(p).Substring(2, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(34, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(66, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(98, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(130, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(162, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(194, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(226, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(258, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(290, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(322, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(354, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(386, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(418, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(450, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(482, 2)\t\t\t\t\t});\t\t\t\t\tstring str = string.Concat(new string[]\t\t\t\t\t{\t\t\t\t\t\tForm1.HexStr(p).Substring(4, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(36, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(68, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(100, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(132, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(164, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(196, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(228, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(260, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(292, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(324, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(356, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(388, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(420, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(452, 2),\t\t\t\t\t\tForm1.HexStr(p).Substring(484, 2)\t\t\t\t\t});\t\t\t\t\tif (a == b)\t\t\t\t\t{\t\t\t\t\t\tMessageBox.Show(\"Flag is: \" + str);\t\t\t\t\t}\t\t\t\t\telse\t\t\t\t\t{\t\t\t\t\t\tMessageBox.Show(\"You have the wrong file!\");\t\t\t\t\t}\t\t\t\t}\t\t\t\tcatch (IOException)\t\t\t\t{\t\t\t\t}\t\t\t}\t\t}Which does this:  Open a new file with OpenFileDialog component and read it into byte array p  Define a string b with value FF0003060C1204121212000100C40307      Define a string a with the concatenation of hex values of bytes at offsets {0,16,32,48,64,80,96,112,128,144,160,176,192,208,224,240} (remember that HexStr returns 0x at the start of the hex string and every byte has a corresponding 2-chars hex string)    Also defines another string str like a but at different offsetsMakes a check if array string a equals string b and if true it will print the flag to be string str&lt;&gt;We can deduce some things here; first it will crash if opened a file with size &lt; 242 bytes (484 / 2)Second, our target here is to open the right file nothing elseOnce I understood that, I knew that the right file is somehow embedded in the binaryI used binwalk to extract any embedded or appended files with this command ` binwalk –dd=”.*” “Cloak and Dagger.exe”The extracted files are so many, so we cannot just open them one by one to get the write fileRather than that I will loop through all files reading them and check for the bytes at the previous indices array to be equal to the hex array FF0003060C1204121212000100C40307`I used this simple script to achieve it&gt;&gt;&gt; from os import listdir&gt;&gt;&gt; from os.path import isfile, join&gt;&gt;&gt; onlyfiles = [f for f in listdir(\".\") if isfile(join(\".\", f))]&gt;&gt;&gt; for file in onlyfiles:...     data = open(file,'rb').read()...     if data[0] == '\\xFF' and data[16] == '\\x00' and data[32] == '\\x03' and data[48] == '\\x06' and data[64] == '\\x0C' and data[80] == '\\x12' and data[96] == '\\x04' and data[112] == '\\x12' and data[128] == '\\x12' and data[144] == '\\x12' and data[160] == '\\x00' and data[176] == '\\x01' and data[192] == '\\x00' and data[208] == '\\xC4' and data[224] == '\\x03' and data[240] == '\\x07':...         print(file)...7F4428So we have the right file 7F4428, open it with our program to get the flag` Flag is Captured ` » D80103060B120712121211FF00000512"
  },
  
  {
    "title": "C++ Structure Polygon Mathematical Operators",
    "url": "/posts/structure-polygon-mathematical-operators/",
    "categories": "Projects, C++",
    "tags": "C++, Math",
    "date": "2017-05-01 08:10:00 +0200",
    





    
    "snippet": "Inroduction  Structure Polygons shaps calculators writen in c++ can do multiple operation on multiple polygon given by points on one string .Project Descriptiona program to do operations on polygon...",
    "content": "Inroduction  Structure Polygons shaps calculators writen in c++ can do multiple operation on multiple polygon given by points on one string .Project Descriptiona program to do operations on polygons data. The program use a defined string format to represent polygons. All polygons will be in one line input. For example:Polygons=[(1,1),(4,1),(4,5),(1,5);(3,4),(6,4),(6,12),(3,12)]Polygons DataThe Polygons line contains a list of polygons data separated by ‘;’. Fields of a Polygon is represented by a set of points separated by ‘,’. The number of polygons are up to 1000 polygon. Each polygon has up to 100 points.Definition of Redundant PointA redundant point is a point of the polygon points that can be deleted without change in the polygon shape. Like  Examples of Redundant Point          (1,1),(2,1),(4,1),(4,3),(1,3)      (1,2),(4,2),(4,2),(4,8),(1,8)      (1,2),(4,2),(4,2),(4,2),(4,8),(1,8)      In the second case two neighbor identical points any one of them can be redundant (you should select only the second one). If more than two points are identical and follow each other, all of them are redundant except the first point of them.Intersecting PolygonsIntersecting Polygons are polygons sharing common area, side, or point(s).Connected PolygonsTwo Connected Polygons are polygons that are intersecting or polygons which have path from one to the other through intersecting polygons.OperationsWhen the program start, the user enters one Polygons Line in the defined above format then followed by one or more operations from the below table (each operation in a line). The program ends when it reads Quit operation.Operations Table            Operation      Action                  Number_Polygons      Print the number of polygons.              Total_Number_Points      Print the total number of points in all polygons.              Minimum_X      Print the minimum X value of all points.              Maximum_X      Print the maximum X value of all points              Minimum_Y      Print the minimum Y value of all points.              Maximum_Y      Print the maximum Y value of all points              Enclosing_Rectangle      Print the minimum Enclosing Rectangle that includes all polygons inside it              Total_Redundant_Points      The number of Redundant points in all polygons              Polygon_Points n      List all points of the nth polygon (neglecting redundant points) n start from 1              Point_Polygons (2,1)      List all polygons IDs(ID is 1 for the first polygon, 2 for the second polygon,…)              List_Polygons_Points More n      List Polygons having more than n points excluding redundant points where n is an integer.              List_Polygons_Points Less n      List Polygons having less than n points excluding redundant points where n is an integer.              List_Polygons_Points Equaln      List Polygons having exactly n points excluding redundant points where n is an integer.              List_Points_Polygons More n      List all Points that are in the list of more than n polygons where n is an integer.              List_Points_Polygons Less n      List all Points that are in the list of less than n polygons where n is an integer.              List_Points_Polygons Equaln      List all Points that are in the list of less than n polygons where n is an integer.              Polygon_Perimeter n      Print the perimeter of the nth polygon.              List_Triangles      List all Polygon IDs of polygons that are triangles.              List_Rectangles      List all Polygon IDs of polygons that are rectangles.              List_Trapezoid      List all Polygon IDs of polygons that are trapezoid.              Inside_RectangleEdge Points      List all Polygon IDs of polygons that are inside the given rectangle.              Inside_Circle  e.g(1,2),5      List all Polygon IDs of polygons that are inside the given Circle Center Raduis              Polygon_Area n      Print the polygon area of the nth polygon              Polygons_Area_Range n1,n2      List all Polygon IDs of polygons that have area &lt;= minArean1 and &gt;=maxArea.n1              Polygons_Enclosing_Point p      List all Polygon IDs of polygons that have the point p (1,2) inside it              Is_Intersecting i,j      Print TRUE if ith polygon intersects the jth polygon              Intersecting_Group 3,5,6      Print TRUE if the list of polygon are all intersecting with each other              Largest_Intersecting_Pair      Print the two IDs of polygons that are intersecting and having the largest sum of area.              Largest_Rectangle_Inside n      Print the largest rectangle that can inside the nth polygon.              Largest_Circle_Inside n      Print the largest circle that can inside the nth polygon.      Code - Some Funcationsint Number_Polygons (string input , int input_length) //function to get polygons number{    int polygon_numbers = 0 ;    for (int i=0 ; i &lt;= input_length ; i++ )    {        if ( input [i]== ';')        {            polygon_numbers = polygon_numbers +1 ;        }    }    return  polygon_numbers+1 ;}int Total_Number_Points (string input , int input_length) //function to get total number of points{    int number_point = 0 ;    for (int i = 0 ; i &lt;= input_length  ; i++ )    {        if (input[i]=='(')        {            number_point = number_point  + 1 ;        }    }    return  number_point ;}int Total_Number_Points (string input , int input_length) //function to get total number of points{    int Redundant_points (string points , int number ) // function to number of redundant at polygon{    int arc[1000]; int col[1000];int inarc[1000];int   counter1= 0;int  counter2= 0 ;int counter3 = 0 ;int colrep = 1  ;    for (int i =0 ;  i&lt;= points.length() ;i++ ) //getting place of that \"(\" and  \")\" and \",\"    {        if (points[i]== '('){counter1=counter1+1;  arc[counter1]=i ;}        if (points[i]== ','){counter2=counter2+1;  col[counter2]=i ;}        if (points[i]== ')'){counter3=counter3+1;inarc[counter3]=i ;}    }    float x[1000]; float y [1000]; float slope[1000];    for (int i = 1 ; i &lt;=number ; i++){        x[i]=atof(points.substr(arc[i]+1,col[colrep]-arc[i]-1).c_str()) ;        y[i]=atof(points.substr(col[colrep]+1,inarc[i]-col[colrep]-1).c_str())  ;        colrep +=2 ;    }    float xr[1000]; float yr[1000];    xr[1]=x[1]; yr[1]=y[1];    //  int repeater = 2 ;    int re =0;    slope[1]=((y[1+1]-y[1])/(x[1+1]-x[1]));    for (int i = 2 ; i&lt;=number ; i++)    {        slope[i]=((y[i+1]-y[i])/(x[i+1]-x[i]));        for (int p =2 ; p &lt;=number ;p++){            if (x[i-1]==x[i] &amp;&amp; y[i-1]==y[i]) { re +=1 ; break; } // get redundant of dip point            if(x[i+1]-x[i] !=0 &amp;&amp; slope[i]==slope[i-1]) { re +=1 ;break; } // getting redundant point of slope            if (x[i+1]-x[i]==0 &amp;&amp; y[i+1]-y[i]!=0 &amp;&amp; x[i]-x[i-1]==0 &amp;&amp; y[i]-y[i-1]!=0 ){  re+=1;   ; break; }// get redundant of x-x =0            // xr[repeater] = x[i];yr[repeater] =y[i];repeater +=1 ;            break ;        }}    //for (int i=1 ;i&lt;repeater ; i++) { cout &lt;&lt; \"X = \" &lt;&lt; xr[i] &lt;&lt; endl;cout &lt;&lt; \"y = \" &lt;&lt; yr[i] &lt;&lt; endl; }    return re ;}}Learn MoreFor Project Code , Visit  Project Repository ."
  }
  
]

